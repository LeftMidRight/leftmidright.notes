# 贪心

## [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

对小孩的胃口值和饼干的尺寸分别进行排序，优先满足胃口小的小孩，这样可以满足尽可能多的孩子。

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int ans = 0;
        Arrays.sort(g);
        Arrays.sort(s);

        int j = 0;

        for(int i = 0; i < g.length; i ++) {
            
            while(j < s.length && s[j] < g[i]) j ++;
            if(j >= s.length) {
                break;
            } else {
                j ++;
                ans ++;
            }

        }

        return ans;
    }
}
```

## [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

**动态规划做法：**

up[i]：表示前 i 个数中最长的以上升结尾的摆动序列

down[i]：表示前 i 个数中最长的以下降结尾的摆动序列

+ 当 nums[i] > nums[i - 1] 的时候，可以作为摆动序列上升的结尾，所以转移方程为：

  ```java
  up[i] = max(up[i - 1], down[i - 1] + 1);
  down[i] = down[i - 1];
  ```

+ 当 nums[i] < nums[i - 1] 的时候，可以作为摆动序列下降的结尾，所以转移方程为：

  ```java
  down[i] = max(down[i - 1], up[i - 1] + 1);
  up[i] = up[i - 1];
  ```

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;

        int[] up = new int[n];
        int[] down = new int[n];

        for(int i = 1; i < n; i ++) {
            if(nums[i] > nums[i - 1]) {
                up[i] = Math.max(up[i - 1], down[i - 1] + 1);
                down[i] = down[i - 1];
            } else if(nums[i] < nums[i - 1]) {
                down[i] = Math.max(down[i - 1], up[i - 1] + 1);
                up[i] = up[i - 1];
            } else {
                up[i] = up[i - 1];
                down[i] = down[i - 1];
            }
        }

        return Math.max(down[n - 1], up[n - 1]) + 1;
    }
}
```

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**动态规划做法**：

dp[i]：表示以下标 i 结尾的最大子数组的和，要使得和最大可得转移方程：

```java
dp[i] = max(dp[i - 1], 0) + nums[i]
```

要么在前面连续的和上加上nums[i]，要么舍弃之前的连续和，让当前的nums[i]作为连续子数组和的开始。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = nums[0];
        int ans = sum;
        for(int i = 1; i < nums.length; i ++) {
            sum = Math.max(sum, 0) + nums[i];
            ans = Math.max(ans, sum);
        }
        return ans;
    } 
}
```

