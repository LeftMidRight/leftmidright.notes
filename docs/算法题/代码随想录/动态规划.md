动态规划

## [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

经典

```java
class Solution {
    public int fib(int n) {
        int[] f = new int[n + 1];
        
        for(int i = 0; i <= n; i ++) {
            if(i == 0) {
                f[i] = 0;
            } else if(i == 1) {
                f[i] = 1;
            } else {
                f[i] = f[i - 1] + f[i - 2];
            }
        }

        return f[n];
    }
}
```

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

对于任意第 i 层台阶，我可以从第 i - 1 层台阶爬上，也可以从第 i - 2层台阶爬上

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];

        for(int i = 1; i <= n; i ++) {
            if(i == 1) {
                dp[1] = 1;
            } else if(i == 2){
                dp[2] = 2;
            } else {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
        }

        return dp[n];
    }
}
```

## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

和爬楼梯一样，当前第 i 层楼梯，可以从 i - 1 层到达，也可以从 i - 2 层到达，比较这两条路的花费，选取花费小的一条

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n + 1];

        dp[0] = 0;
        dp[1] = 0;

        for(int i = 2; i <= n; i ++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);    
        }
        
        return dp[n];
    }
}
```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

当前位置可以从左边走过来，也可以从上面走过来，从上面走过来的路径数加上从左边走过来的路径数就是总的路径条数

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];

        for(int i = 0; i < m; i ++) {
            for(int j = 0; j < n; j ++) {
                if(i == 0 && j == 0) {
                    dp[i + 1][j + 1] = 1;
                } else {
                    dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1];
                }
            }
        }

        return dp[m][n];
    }
}
```

## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

与上一题不同，这题需要考虑当前位置是否有路障，如果有路障那么当前位置的可到达路径跳数就是0。还有要判断初始位置是否摆放了路障，如果初始位置有路障那么答案直接为0

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        
        if(obstacleGrid[0][0] == 1) {
            return 0;
        }

        int n = obstacleGrid.length;
        int m = obstacleGrid[0].length;

        int[][] dp = new int[n + 1][m + 1];

        for(int i = 0; i < n; i ++) {
            for(int j = 0; j < m; j ++) {
                if(i == 0 && j == 0) {
                    dp[i + 1][j + 1] = 1;
                } else if(obstacleGrid[i][j] == 1) {
                    dp[i + 1][j + 1] = 0;
                } else {
                    dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];
                }
            }
        }

        return dp[n][m];
    }
}
```

## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)





## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

当选定一个数作为根节点的时候，以该根节点构造的二叉搜索树的不同种类共有 dp[left] * dp[right] 种

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];

        for(int i = 0; i <= n; i ++) {
            if(i == 0 || i == 1) {
                dp[i] = 1;
            } else if(i == 2) {
                dp[i] = 2;
            } else {
                for(int j = 1; j <= i; j ++) {
                    dp[i] += dp[j - 1] * dp[i - j];
                }
            }
        }

        return dp[n];
    }
}
```

## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

$dp[i][j]$数组定义：从前 i 个数选，能否选出和大小为 j 的集合

可得状态转移方程: $dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]$

分别对应选当前数和不选当前数的结果

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num : nums) sum += num;

        if(sum % 2 == 1) {
            return false;
        } 

        boolean[] dp = new boolean[sum / 2 + 1];

        dp[0] = true;

        for(int i = 0; i < nums.length; i ++) {
            for(int j = sum / 2; j >= nums[i]; j --) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }

        return dp[sum / 2];
    }
}
```

## [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

和分割等和子集一样，把石头分成两堆，然后再一起粉碎，查看分成两堆后这两堆的绝对值差的最小值

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for(int stone : stones) sum += stone;

        boolean[] dp = new boolean[sum + 1];

        dp[0] = true;

        for(int i = 0; i < stones.length; i ++) {
            for(int j = sum; j >= stones[i]; j --) {
                dp[j] = dp[j] || dp[j - stones[i]];
            }
        }

        int ans = Integer.MAX_VALUE;
        for(int i = 1; i <= sum; i ++) {
            if(dp[i]) {
                ans = Math.min(ans, Math.abs(sum - 2 * i));
            }
        }

        return ans;
    }
}
```

## [494. 目标和](https://leetcode.cn/problems/target-sum/)

设整个数组和为 $S$，选出来加负号的数的和为 $N$，没有加负号的数和为 $P$，则可以得到 $N + P = S, P - N = target$ ，所以 $2 * P = S + target, P = (S + target) / 2$

此时问题转化为求从数组 nums 中选出一个集合，集合的和为 (S + target) / 2 的选法有多少种。注意，如果 S + target 不是偶数的话，则无解

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int s = 0;
        for(int num : nums) s += num;

        if((target + s) % 2 != 0 || (target + s) < 0) {
            return 0;
        }

        target = (target + s) / 2;

        int[] dp = new int[target + 1];

        dp[0] = 1;

        for(int i = 0; i < nums.length; i ++) {
            for(int j = target; j >= nums[i]; j --) {
                dp[j] += dp[j - nums[i]];
            }
        }

        return dp[target];
    }
}
```

## [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

```java
dp[j][k] 表示 选出来 j 个 0 和 k 个 1 的子集的长度有多长
则可以得到转移方程: dp[j][k] = max(dp[j][k], dp[j - cnt0[i]][k - cnt1[i]])
```
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;

        int[] cnt0 = new int[len + 1];
        int[] cnt1 = new int[len + 1];

        for(int i = 0; i < len; i ++) {
            int c0 = 0;
            int c1 = 0;
            for(char c : strs[i].toCharArray()) {
                if(c == '0') c0 ++;
                else c1 ++;
            }

            cnt0[i] = c0;
            cnt1[i] = c1;
        }

        int[][] dp = new int[m + 1][n + 1];

        for(int i = 0; i < len; i ++) {
            for(int j = m; j >= cnt0[i]; j --) {
                for(int k = n; k >= cnt1[i]; k --) {
                    dp[j][k] = Math.max(dp[j][k], dp[j - cnt0[i]][k - cnt1[i]] + 1);
                }
            }
        }
        
        return dp[m][n];
    }
}
```



## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

完全背包问题

```java
class Solution {
    public int change(int amount, int[] coins) {
        int n = coins.length;

        int[][] dp = new int[n + 1][amount + 1];
        
        dp[0][0] = 1;

        for(int i = 0; i < n; i ++) {
            for(int j = 0; j <= amount; j ++) {
                for(int k = 0; k * coins[i] <= j; k ++) {
                    dp[i + 1][j] += dp[i][j - k * coins[i]];
                }
            }
        }
        
        return dp[n][amount];
    } 
}
```

