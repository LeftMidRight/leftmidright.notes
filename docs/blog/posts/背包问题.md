---
title: 背包问题
date: 2025-04-14
categories:
    - 算法
comments: true
---

>你的背包，让我走的好缓慢~

背包问题的推导和代码，包含：01背包，完全背包，多重背包，分组背包

<!-- more -->

# 背包问题

背包问题是动态规划问题中**选或者不选**的典型代表, 从0x3f博主视频中，可以学习到用记忆化搜索的方式思考dp问题，这样可以让我们在写递推的时候，比较容易地想到状态数组的定义。
本文将依照 记忆化搜索 -> dp数组 -> dp数组优化 的方式一步步讲解背包问题。


## 1. 01背包问题
>问题描述：有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

首先我们想怎么样写出一个暴力搜索，可以覆盖全部的情况然后记录最大价值呢？于是开始构造搜索函数，可以发现对于第 $i$ 件物品，我们要么**选择它要么不选择它**，选取这二者的最大值，根据这两种情况得到搜索的方向，可以得到搜索函数：

$$
dfs(i, j) = 
\begin{cases}
dfs(i-1,j) & \text{if } j < v[i] \\ \\
\max (dfs(i-1,j), dfs(i-1,j-v[i])+w[i]) & \text{if } j \ge[i]
\end{cases}
$$


$i$ 代表第 $i$ 个物品，$j$ 代表当前背包的体积，$dfs(i,j)$ 代表从前 $i$ 个物品中选，选出体积为 $j$ 的物品的最大价值。

可以知道搜索函数的代码：
```java
public int dfs(int i, int j) {
    if(i < 0) {
        return 0;
    }
    int ans = dfs(i - 1, j);
    if(j >= v[i]) {
        ans = Math.max(ans, dfs(i - 1, j - v[i]) + w[i]);
    }
    return ans;
}
```
## 2. 完全背包问题

## 3. 多重背包问题

## 4. 分组背包问题

