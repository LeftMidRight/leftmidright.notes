# 0-Redis全景图

Redis 的两大维度和三大主线

两大维度：应用维度和系统维度

三大主线：高性能、高可靠、高可扩展

![](https://cdn.nlark.com/yuque/0/2025/jpeg/42909957/1750936599011-393d65e8-2cab-4f55-a7ea-365e37b103c5.jpeg)

在**系统维度**，围绕着三条主线，我们可以得出学习的重点

**高性能主线：** 包括线程模型、数据接口、持久化、网络框架

**高可靠主线：** 主从复制、哨兵机制

**高可扩展主线：** 数据分片、负载均衡

在**应用维度**上，可以按照 ”**应用场景驱动**“ 和 ”**典型案例驱动**“ 两种进行学习



Redis 问题画像图

![](https://cdn.nlark.com/yuque/0/2025/jpeg/42909957/1750937077109-4f5aab68-61da-4c87-9254-a0df1eaf03ce.jpeg)



# 1-Redis基本架构
## 1.构造一个 SimpleKV

构思如果要构造一个具有关键组件的键值数据库 SimpleKV，要怎么设计？

## 2.SimpleKV 的数据模型和操作接口

### 2.1 数据模型

对于键值数据库来说，基本的数据模型是 key-value 模型。在 SimpleKV 中，key 是 String 类型，而 value 是基本数据类型，例如 String、int 等。

不同键值数据库支持的 key 类型一般差异不大，而 value 类型则有较大差别。Redis 支持的 value 类型包括了 String、哈希表、列表、集合等。从使用的角度来说，不同的业务场景适合使用不同的数据类型，而且也隐含着不同数据结构在性能、空间效率等方面的差异，从而导致不同的 value 操作之间存在着差异。

### 2.2 操作接口

+ PUT：新写入或更新一个 kv 对
+ GET：根据一个 k 获取 v
+ DELETE：根据一个 k 删除整个 k-v 对

在实际的业务场景中，经常会有这样一个需求：”查询用户在一段时间内的访问记录“。这种操作在键值数据库属于 SCAN 操作，即**根据一段 key 的范围返回相应的 value 值。**因此 PUT/GET/DELETE/SCAN 是一个键值数据库的基本操作集合。

## 3.SimpleKV 的存储

键值对保存在内存还是硬盘

+ 内存：读写速度快。风险是一旦停电，所有的数据都会丢失
+ 磁盘：可以避免数据丢失。读写速度慢，键值数据库的整体性能会被拉低

![](https://cdn.nlark.com/yuque/0/2025/jpeg/42909957/1750938844393-28ea448e-e6d6-4451-a06d-3f0be16a9a4c.jpeg)

## 4.访问模式

1. 通过函数库调用的方式供外部应用使用（libsimplekv.so）
2. 通过网络框架以 Socket 通信的形式对外提供键值对操作

**Redis 是通过网络框架访问从客户端访问服务器端的**

那么在 Redis 客户端通过网络通信的方式给服务端发送指令是，网络连接的处理，网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？如何进行设计和取舍呢？这个问题称为 I/O 模型设计，不同的 I/O 模型对键值数据库的性能和可扩展性会有不同的影响。

+ 如果设计成**单线程**：一旦在处理网络连接，网络请求解析和数据存取的过程中出现了阻塞，那么整个线程就会被阻塞，这就降低了系统的响应速度
+ 如果涉及成**多线程**：此时如果一个线程发生阻塞，其他线程还可以正常运行，但是不同线程间如果需要访问共享资源，那么又会产生线程的竞争，也会影响系统效率

## 5.SimpleKV 的索引

索引的类型有很多，常见的有哈希表、B+树、字典树等

一般而言，内存键值数据库（如 Redis）采用**哈希表**作为索引，很大一部分原因在于，其键值数据基本是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。与 SimpleKV 中 value 只存储基本数据类型不同，Redis 的 value 有很多类型，那么就要涉及在 value 中再寻找目标值的操作，所以对于 Redis 的 value 也需要建立索引。

## 6.SimpleKV 的持久化

SimpleKV 虽然依赖于内存保存数据，提供快速访问，但是我们也希望 SimpleKV 重启后能快速重新提供服务，所以我们在 SimpleKV 的存储模块中增加了**持久化功能**。不过鉴于磁盘管理要比内存管理复杂，SimpleKV 就直接采用了文件形式，将键值数据通过调用本地文件系统的操作接口保存在磁盘上。

那么**什么时候把内存中的键值数据保存到文件中呢？**

+ 对于每次写入的键值对，都进行落盘处理。这样处理虽然让数据更加可靠，但是每次写入都要落盘，数据库的性能会被拉低
+ 起一个定时任务，周期性的把内存中的键值对写进到磁盘中，这样可以避免频繁写进磁盘带来的性能影响。

## 总结

![](https://cdn.nlark.com/yuque/0/2025/jpeg/42909957/1750940721683-91b38414-9080-435c-a9df-ea04e7cbbd6b.jpeg)



