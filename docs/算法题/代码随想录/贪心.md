# 贪心

## [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

对小孩的胃口值和饼干的尺寸分别进行排序，优先满足胃口小的小孩，这样可以满足尽可能多的孩子。

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int ans = 0;
        Arrays.sort(g);
        Arrays.sort(s);

        int j = 0;

        for(int i = 0; i < g.length; i ++) {
            
            while(j < s.length && s[j] < g[i]) j ++;
            if(j >= s.length) {
                break;
            } else {
                j ++;
                ans ++;
            }

        }

        return ans;
    }
}
```

## [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

**动态规划做法：**

up[i]：表示前 i 个数中最长的以上升结尾的摆动序列

down[i]：表示前 i 个数中最长的以下降结尾的摆动序列

+ 当 nums[i] > nums[i - 1] 的时候，可以作为摆动序列上升的结尾，所以转移方程为：

  ```java
  up[i] = max(up[i - 1], down[i - 1] + 1);
  down[i] = down[i - 1];
  ```

+ 当 nums[i] < nums[i - 1] 的时候，可以作为摆动序列下降的结尾，所以转移方程为：

  ```java
  down[i] = max(down[i - 1], up[i - 1] + 1);
  up[i] = up[i - 1];
  ```

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;

        int[] up = new int[n];
        int[] down = new int[n];

        for(int i = 1; i < n; i ++) {
            if(nums[i] > nums[i - 1]) {
                up[i] = Math.max(up[i - 1], down[i - 1] + 1);
                down[i] = down[i - 1];
            } else if(nums[i] < nums[i - 1]) {
                down[i] = Math.max(down[i - 1], up[i - 1] + 1);
                up[i] = up[i - 1];
            } else {
                up[i] = up[i - 1];
                down[i] = down[i - 1];
            }
        }

        return Math.max(down[n - 1], up[n - 1]) + 1;
    }
}
```

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**动态规划做法**：

dp[i]：表示以下标 i 结尾的最大子数组的和，要使得和最大可得转移方程：

```java
dp[i] = max(dp[i - 1], 0) + nums[i]
```

要么在前面连续的和上加上nums[i]，要么舍弃之前的连续和，让当前的nums[i]作为连续子数组和的开始。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = nums[0];
        int ans = sum;
        for(int i = 1; i < nums.length; i ++) {
            sum = Math.max(sum, 0) + nums[i];
            ans = Math.max(ans, sum);
        }
        return ans;
    } 
}
```

## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**动态规划做法**：

DP状态机，设置两个dp数组:

```java
dp[i][0] // 表示以 i 结尾，未持有股票的最大利润
dp[i][1] // 表示以 i 结尾，持有股票的最大利润
// 可得状态转移方程
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + price[i])
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - price[i])

// 由于同一位置，未持有股票的利润一定大于等于持有股票的利润，所以最后答案就是 dp[i][0]
// 对于边界位置的初始化：
dp[i][0] = 0, dp[i][1] = -inf
```

可得代码：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;

        int[][] dp = new int[n + 1][2];

        dp[0][0] = 0;
        dp[0][1] = Integer.MIN_VALUE;

        for(int i = 0; i < n; i ++) {
            dp[i + 1][1] = Math.max(dp[i][1], dp[i][0] - prices[i]);
            dp[i + 1][0] = Math.max(dp[i][0], dp[i][1] + prices[i]);
        }

        return dp[n][0];
    }
}
```

## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)



## [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)



## [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

先找到正数和负数的分界线，然后优先把负数变成正数。当数组里面全部是正数的时候，如果 k 是偶数或者数组里面包含 0 值，那么当前数组和就是最大值，如果 k 是奇数，那么就把当前数组中的最小值变成负数。

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);

        int par = 0;
        while(par < nums.length && nums[par] < 0) {
            par ++;
        }

        for(int i = 0; i < par && k > 0; i ++) {
            nums[i] = -nums[i];
            k --;
        }

        if((par < nums.length && nums[par] == 0) || k % 2 == 0) {
            k = 0;
        }

        Arrays.sort(nums);
        if(k > 0) {
            nums[0] = -nums[0];
        }

        int ans = 0;
        for(int i = 0; i < nums.length; i ++) {
            ans += nums[i];
        }

        return ans;
    }
}
```

## [134. 加油站](https://leetcode.cn/problems/gas-station/)

首先要知道当 sum(gas) >= sum(cost) 的时候一定有解，sum(gas) < sum(cost) 的时候一定无解





## [135. 分发糖果](https://leetcode.cn/problems/candy/)

从左往右发，不确定糖果数的先放 1 个，再从右往左发

```java
class Solution {
    public int candy(int[] ratings) {
        int ans = 0;
        int n = ratings.length;
        
        if(n == 1) {
            return 1;
        }

        int[] f = new int[n];

        for(int i = 0; i < n; i ++) {
            if(i == 0) {
                f[i] = 1;
            } else if(ratings[i] > ratings[i - 1]) {
                f[i] = f[i - 1] + 1;
            } else {
                f[i] = 1;
            }
        }

        for(int i = n - 2; i >= 0; i --) {
            if(ratings[i] > ratings[i + 1] && f[i] <= f[i + 1]) {
                f[i] = f[i + 1] + 1;
            }
        }

        for(int i = 0; i < n; i ++) {
            ans += f[i];
        }
        
        return ans;
    }
}
```

## [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

先找10块的，再找5块的，以免后面有付10块的找不开

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        
        int m5 = 0;
        int m10 = 0;
        int m20 = 0;

        for(int bill : bills) {
            if(bill == 5) {
                m5 ++;
            } else if(bill == 10) {
                if(m5 == 0) {
                    return false;
                } else {
                    m5 --;
                    m10 ++;
                }
            } else {
                if((m5 * 5 + m10 * 10) < 15 || m5 == 0) {
                    return false;
                } else if(m10 >= 1) {
                    m10 --;
                    m5 --;
                    m20 ++;
                } else {
                    m5 -= 3;
                    m20 ++;
                }
            }
        }

        return true;
    }
}
```

## [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

